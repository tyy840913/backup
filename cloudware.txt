// Worker ä»£ç 

// è¾…åŠ©å‡½æ•°ï¼šè§£ç å¹¶ç¼–ç  Basic Auth
function getAuthHeader(username, password) {
  const credentials = `${username}:${password}`;
  const encoded = btoa(credentials);
  return `Basic ${encoded}`;
}

function decodeBasicAuth(authHeader) {
  if (!authHeader || !authHeader.startsWith('Basic ')) return null;
  try {
    const encoded = authHeader.substring(6);
    const decoded = atob(encoded);
    const [username, password] = decoded.split(':');
    return { username, password };
  } catch (e) {
    return null;
  }
}

// è¾…åŠ©å‡½æ•°ï¼šæ ¹æ®æ–‡ä»¶åçŒœæµ‹ MIME ç±»å‹
function guessContentType(filename) {
  const fileExtension = filename.split('.').pop().toLowerCase();
  const mimeTypes = {
    'sh': 'application/x-sh', 'js': 'application/javascript', 'txt': 'text/plain',
    'html': 'text/html', 'css': 'text/css', 'json': 'application/json',
    'jpg': 'image/jpeg', 'jpeg': 'image/jpeg', 'png': 'image/png', 'gif': 'image/gif',
    'svg': 'image/svg+xml', 'webp': 'image/webp', 'pdf': 'application/pdf',
    'zip': 'application/zip', 'tar': 'application/x-tar', 'gz': 'application/gzip',
    'mp3': 'audio/mpeg', 'mp4': 'video/mp4'
  };
  return mimeTypes[fileExtension] || 'application/octet-stream';
}

// --- æ–‡ä»¶ç®¡ç†å™¨ HTML é¡µé¢ ---
const fileManagerHtml = `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>KV è·¨åŸŸæ–‡ä»¶ç®¡ç†å™¨</title>
  <style>
    :root {
      --primary-color: #007bff; --border-color: #dee2e6; --hover-bg-color: #e9ecef;
      --text-color: #212529; --folder-color: #f7b731; --file-color: #adb5bd;
      --danger-color: #dc3545; --success-color: #28a745;
    }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; margin: 0; background-color: #f8f9fa; }
    .container { max-width: 960px; margin: 0 auto; padding: 20px; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
    header { display: flex; justify-content: space-between; align-items: center; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); margin-bottom: 20px; }
    h1 { font-size: 1.75rem; margin: 0; }
    #file-input { display: none; }
    .upload-btn { background-color: var(--primary-color); color: white; padding: 8px 12px; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; }
    .upload-btn:hover { background-color: #0056b3; }
    .upload-btn:disabled { background-color: #a0a0a0; cursor: not-allowed; }
    #path-breadcrumbs { font-size: 1rem; margin-bottom: 20px; color: #6c757d; white-space: nowrap; overflow-x: auto; }
    #file-list { list-style: none; padding: 0; border: 1px solid var(--border-color); border-radius: 5px; }
    #file-list li { display: flex; align-items: center; padding: 12px 15px; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s; }
    #file-list li:last-child { border-bottom: none; }
    #file-list li:hover { background-color: var(--hover-bg-color); }
    .item-icon { width: 24px; height: 24px; margin-right: 15px; flex-shrink: 0; }
    .item-name { flex-grow: 1; cursor: pointer; color: var(--text-color); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .item-name.folder { font-weight: 500; }
    .item-actions { display: flex; align-items: center; }
    .item-actions button { background: none; border: none; cursor: pointer; padding: 5px; margin-left: 8px; opacity: 0.7; }
    .item-actions button:hover { opacity: 1; }
    .item-actions svg { width: 18px; height: 18px; vertical-align: middle; }
    #status-message { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(0,0,0,0.75); color: white; padding: 10px 20px; border-radius: 5px; display: none; z-index: 1000; }
    
    /* Modal styles */
    .modal { display: none; position: fixed; z-index: 1001; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4); overflow: auto; }
    .modal-content { background-color: #fefefe; margin: 2% auto; padding: 10px; /* Reduced padding */ border: 1px solid #888; border-radius: 5px; width: 80%; max-width: 500px; max-height: 80vh; overflow-y: auto; }
    .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
    .close:hover, .close:focus { color: black; text-decoration: none; }
    .modal input, .modal select { width: 100%; padding: 8px; margin: 10px 0; box-sizing: border-box; }
    .modal-buttons { text-align: right; margin-top: 15px; }
    .modal-buttons button { margin-left: 10px; padding: 8px 15px; border: none; border-radius: 3px; cursor: pointer; }
    .btn-cancel { background-color: #ccc; }
    .btn-confirm { background-color: var(--primary-color); color: white; }
    .btn-danger { background-color: var(--danger-color); color: white; }
    
    /* Editor modal */
    #editor-modal .modal-content { 
      width: 95%; 
      max-width: 95%; 
      height: 90vh;
      max-height: 90vh; 
      display: flex; 
      flex-direction: column; 
    }
    .editor-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-bottom: 2px; /* Further reduced */
      margin-bottom: 10px;
      border-bottom: 1px solid var(--border-color);
    }
    .editor-header h2 {
      margin: 0;
      font-size: 1.1rem;
    }
    .editor-header .close {
      font-size: 1.5rem; /* Reduced close button size */
      line-height: 1;
    }
    .editor-toolbar {
      padding-bottom: 10px;
      margin-bottom: 10px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between; /* This will separate the button groups */
      align-items: center;
    }
    .editor-toolbar > div { /* Target the left and right group divs */
      display: flex;
      gap: 8px;
    }
    .editor-toolbar button {
      padding: 5px 10px;
      border: 1px solid var(--border-color);
      background-color: #f8f9fa;
      border-radius: 4px;
      cursor: pointer;
    }
    .editor-toolbar button:hover {
      background-color: var(--hover-bg-color);
    }
    /* Re-apply specific button styles for toolbar context */
    .editor-toolbar .btn-cancel {
        background-color: #ccc;
        color: black;
    }
    .editor-toolbar .btn-confirm {
        background-color: var(--primary-color);
        color: white;
    }
    #editor-textarea { 
      flex-grow: 1; 
      width: 100%; 
      font-family: monospace; 
      font-size: 14px; 
      resize: none; 
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 10px;
      box-sizing: border-box;
    }
    
    /* Directory tree */
    .directory-tree { max-height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; margin: 10px 0; }
    .directory-tree ul { list-style-type: none; padding-left: 20px; }
    .directory-tree > ul { padding-left: 0; }
    .directory-tree li { cursor: pointer; padding: 3px 0; }
    .directory-tree li.folder::before { content: "ğŸ“ "; }
    .directory-tree li.file::before { content: "ğŸ“„ "; }
    .directory-tree li.selected { background-color: #e9ecef; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>KV è·¨åŸŸæ–‡ä»¶ç®¡ç†å™¨</h1>
      <div class="header-buttons">
        <button type="button" id="new-file-btn" class="upload-btn" disabled>æ–°å»ºæ–‡ä»¶</button>
        <form id="upload-form" style="display: inline;">
          <input type="file" id="file-input" multiple>
          <button type="button" id="upload-btn" class="upload-btn" onclick="document.getElementById('file-input').click();" disabled>ä¸Šä¼ æ–‡ä»¶</button>
        </form>
      </div>
    </header>
    <div id="path-breadcrumbs"></div>
    <ul id="file-list"></ul>
  </div>
  
  <!-- å¤åˆ¶/ç§»åŠ¨æ–‡ä»¶æ¨¡æ€æ¡† -->
  <div id="copy-move-modal" class="modal">
    <div class="modal-content">
      <span class="close">&times;</span>
      <h2 id="copy-move-title">å¤åˆ¶/ç§»åŠ¨æ–‡ä»¶</h2>
      <p>æºæ–‡ä»¶: <span id="copy-move-source"></span></p>
      <label for="copy-move-destination">ç›®æ ‡è·¯å¾„:</label>
      <input type="text" id="copy-move-destination" placeholder="è¾“å…¥ç›®æ ‡è·¯å¾„">
      <div>
        <label>é€‰æ‹©åŸŸå:</label>
        <div class="directory-tree" id="directory-tree"></div>
      </div>
      <div class="modal-buttons">
        <button class="btn-cancel">å–æ¶ˆ</button>
        <button class="btn-confirm" id="confirm-copy-btn">å¤åˆ¶åˆ°</button>
        <button class="btn-confirm" id="confirm-move-btn">ç§»åŠ¨åˆ°</button>
      </div>
    </div>
  </div>
  
  <!-- é‡å‘½åæ–‡ä»¶æ¨¡æ€æ¡† -->
  <div id="rename-modal" class="modal">
    <div class="modal-content">
      <span class="close">&times;</span>
      <h2>é‡å‘½åæ–‡ä»¶</h2>
      <p>å½“å‰åç§°: <span id="rename-source"></span></p>
      <label for="rename-destination">æ–°åç§°:</label>
      <input type="text" id="rename-destination" placeholder="è¾“å…¥æ–°åç§°">
      <div class="modal-buttons">
        <button class="btn-cancel">å–æ¶ˆ</button>
        <button class="btn-confirm" id="confirm-rename">é‡å‘½å</button>
      </div>
    </div>
  </div>
  
  <!-- åœ¨çº¿ç¼–è¾‘æ¨¡æ€æ¡† -->
  <div id="editor-modal" class="modal">
    <div class="modal-content">
      <div class="editor-header">
        <h2>ç¼–è¾‘æ–‡ä»¶: <span id="editor-filename"></span></h2>
        <span class="close">&times;</span>
      </div>
      <div class="editor-toolbar">
        <div> <!-- Left Group -->
          <button id="format-json-btn" title="æ ¼å¼åŒ–JSON">æ ¼å¼åŒ–JSON</button>
          <button id="minify-json-btn" title="å‹ç¼©JSON">å‹ç¼©JSON</button>
        </div>
        <div> <!-- Right Group -->
          <button class="btn-cancel">å–æ¶ˆ</button>
          <button class="btn-confirm" id="save-editor">ä¿å­˜</button>
        </div>
      </div>
      <textarea id="editor-textarea"></textarea>
    </div>
  </div>
  
  <!-- æ–°å»ºæ–‡ä»¶æ¨¡æ€æ¡† -->
  <div id="new-file-modal" class="modal">
    <div class="modal-content">
      <span class="close">&times;</span>
      <h2>æ–°å»ºæ–‡ä»¶</h2>
      <label for="new-filename">æ–‡ä»¶å:</label>
      <input type="text" id="new-filename" placeholder="ä¾‹å¦‚: new-file.txt">
      <div class="modal-buttons">
        <button class="btn-cancel">å–æ¶ˆ</button>
        <button class="btn-confirm" id="confirm-new-file">åˆ›å»º</button>
      </div>
    </div>
  </div>

  <div id="status-message"></div>

  <script>
    const icons = {
      folder: '<svg class="item-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="var(--folder-color)"><path d="M10 4H4c-1.1 0-2 .89-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"/></svg>',
      file: '<svg class="item-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="var(--file-color)"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zM13 9V3.5L18.5 9H13z"/></svg>',
      download: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>',
      delete: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="var(--danger-color)"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>',
      copy: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>',
      move: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>',
      edit: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>',
      rename: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L3 22h3l1.5-4h9l1.5 4h3L12 2zm-1.38 14L12 7.67 13.38 16h-2.76z"/></svg>'
    };

    let allFilesByDomain = {};
    let currentPath = ''; // e.g., "my-worker.dev/folder/"
    let currentDomain = '';
    let currentFileForOperation = null; // ç”¨äºè·Ÿè¸ªå½“å‰æ“ä½œçš„æ–‡ä»¶

    document.addEventListener('DOMContentLoaded', () => {
      render();
      document.getElementById('file-input').addEventListener('change', handleFileUpload);
      
      // è®¾ç½®æ¨¡æ€æ¡†å…³é—­äº‹ä»¶
      setupModalEvents();
    });

    function setupModalEvents() {
      // æ–°å»ºæ–‡ä»¶æ¨¡æ€æ¡†äº‹ä»¶
      document.getElementById('new-file-btn').onclick = () => {
        document.getElementById('new-filename').value = '';
        document.getElementById('new-file-modal').style.display = 'block';
      };
      document.getElementById('new-file-modal').querySelector('.close').onclick = () => {
        document.getElementById('new-file-modal').style.display = 'none';
      };
      document.getElementById('new-file-modal').querySelector('.btn-cancel').onclick = () => {
        document.getElementById('new-file-modal').style.display = 'none';
      };
      document.getElementById('confirm-new-file').onclick = handleNewFileConfirm;

      // å¤åˆ¶/ç§»åŠ¨æ¨¡æ€æ¡†äº‹ä»¶
      document.getElementById('copy-move-modal').querySelector('.close').onclick = () => {
        document.getElementById('copy-move-modal').style.display = 'none';
      };
      document.getElementById('copy-move-modal').querySelector('.btn-cancel').onclick = () => {
        document.getElementById('copy-move-modal').style.display = 'none';
      };
      document.getElementById('confirm-copy-btn').onclick = () => handleCopyMoveConfirm('copy');
      document.getElementById('confirm-move-btn').onclick = () => handleCopyMoveConfirm('move');
      
      // é‡å‘½åæ¨¡æ€æ¡†äº‹ä»¶
      document.getElementById('rename-modal').querySelector('.close').onclick = () => {
        document.getElementById('rename-modal').style.display = 'none';
      };
      document.getElementById('rename-modal').querySelector('.btn-cancel').onclick = () => {
        document.getElementById('rename-modal').style.display = 'none';
      };
      document.getElementById('confirm-rename').onclick = handleRenameConfirm;
      
      // ç¼–è¾‘å™¨æ¨¡æ€æ¡†äº‹ä»¶
      document.getElementById('editor-modal').querySelector('.close').onclick = () => {
        document.getElementById('editor-modal').style.display = 'none';
      };
      document.getElementById('editor-modal').querySelector('.btn-cancel').onclick = () => {
        document.getElementById('editor-modal').style.display = 'none';
      };
      document.getElementById('save-editor').onclick = handleSaveEditor;

      // JSON å·¥å…·æŒ‰é’®äº‹ä»¶
      document.getElementById('format-json-btn').onclick = () => formatJson(true);
      document.getElementById('minify-json-btn').onclick = () => formatJson(false);
      
      // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
      window.onclick = function(event) {
        if (event.target.classList.contains('modal')) {
          event.target.style.display = 'none';
        }
      };
    }

    function showStatus(message, isError = false, duration = 3000) {
      const statusElement = document.getElementById('status-message');
      statusElement.textContent = message;
      statusElement.style.backgroundColor = isError ? 'var(--danger-color)' : 'rgba(0,0,0,0.75)';
      statusElement.style.display = 'block';
      setTimeout(() => { statusElement.style.display = 'none'; }, duration);
    }

    async function render() {
      try {
        const response = await fetch('/list-keys');
        if (!response.ok) throw new Error('æ— æ³•è·å–æ–‡ä»¶åˆ—è¡¨: ' + await response.text());
        allFilesByDomain = await response.json();
        currentDomain = allFilesByDomain.currentDomain;
        renderFileList();
        renderBreadcrumbs();
        updateUploadButtonState();
      } catch (error) {
        showStatus('é”™è¯¯: ' + error.message, true);
      }
    }
    
    function updateUploadButtonState() {
        const uploadBtn = document.getElementById('upload-btn');
        const newFileBtn = document.getElementById('new-file-btn');
        const canOperate = !!currentPath;

        uploadBtn.disabled = !canOperate;
        newFileBtn.disabled = !canOperate;

        const title = canOperate ? 'å¯ä»¥åœ¨å½“å‰ç›®å½•æ“ä½œ' : 'è¯·å…ˆè¿›å…¥ä¸€ä¸ªåŸŸåç›®å½•';
        uploadBtn.title = title;
        newFileBtn.title = title;
    }

    function renderBreadcrumbs() {
      const breadcrumbs = document.getElementById('path-breadcrumbs');
      breadcrumbs.innerHTML = '';
      const rootLink = document.createElement('a');
      rootLink.href = '#';
      rootLink.textContent = 'æ‰€æœ‰åŸŸ';
      rootLink.onclick = (e) => { e.preventDefault(); currentPath = ''; renderFileList(); renderBreadcrumbs(); updateUploadButtonState(); };
      breadcrumbs.appendChild(rootLink);

      const parts = currentPath.split('/').filter(p => p);
      let path = '';
      parts.forEach(part => {
        path += part + '/';
        breadcrumbs.appendChild(document.createTextNode(' / '));
        const link = document.createElement('a');
        link.href = '#';
        link.textContent = part;
        const capturedPath = path;
        link.onclick = (e) => { e.preventDefault(); currentPath = capturedPath; renderFileList(); renderBreadcrumbs(); updateUploadButtonState(); };
        breadcrumbs.appendChild(link);
      });
    }

    function renderFileList() {
      const fileListEl = document.getElementById('file-list');
      fileListEl.innerHTML = '';
      const pathDomain = currentPath.split('/')[0];
      const keys = allFilesByDomain[pathDomain] || [];

      // Root view: show domains as folders
      if (!currentPath) {
        Object.keys(allFilesByDomain).filter(k => k !== 'currentDomain').forEach(domain => {
          const li = document.createElement('li');
          li.innerHTML = icons.folder + '<span class="item-name folder">' + domain + '</span>';
          li.onclick = () => { currentPath = domain + '/'; renderFileList(); renderBreadcrumbs(); updateUploadButtonState(); };
          fileListEl.appendChild(li);
        });
        if (fileListEl.children.length === 0) {
             const li = document.createElement('li');
             li.textContent = 'æœªé…ç½®å…¶ä»–åŸŸåæˆ–è·å–å¤±è´¥';
             li.style.justifyContent = 'center';
             fileListEl.appendChild(li);
        }
        return;
      }

      const items = new Map();
      const pathWithinDomain = currentPath.substring(pathDomain.length + 1); // e.g., "folder/" or ""
      const pathPrefixLength = pathWithinDomain.length;
      keys.forEach(key => {
        if (key.startsWith(pathWithinDomain)) {
           const remaining = key.substring(pathPrefixLength);
           const name = remaining.split('/')[0];
           if (name) {
             const isFolder = remaining.includes('/') && remaining !== name;
             items.set(name, { type: isFolder ? 'folder' : 'file', name });
           }
        }
      });

      if (items.size === 0) {
        const li = document.createElement('li');
        li.textContent = 'æ­¤ç›®å½•ä¸ºç©º';
        li.style.justifyContent = 'center';
        fileListEl.appendChild(li);
        return;
      }

      const sortedItems = Array.from(items.values()).sort((a, b) => {
        if (a.type === b.type) return a.name.localeCompare(b.name);
        return a.type === 'folder' ? -1 : 1;
      });

      sortedItems.forEach(item => {
        const li = document.createElement('li');
        const fullPath = currentPath + item.name;
        const fullKey = pathWithinDomain + item.name;
        li.innerHTML = item.type === 'folder' ? icons.folder : icons.file;
        
        const nameSpan = document.createElement('span');
        nameSpan.className = 'item-name' + (item.type === 'folder' ? ' folder' : '');
        nameSpan.textContent = item.name;
        li.appendChild(nameSpan);

        if (item.type === 'folder') {
          li.onclick = () => { currentPath = fullPath + '/'; renderFileList(); renderBreadcrumbs(); };
        } else {
          const actions = document.createElement('div');
          actions.className = 'item-actions';
          
          // ç¼–è¾‘æŒ‰é’®ï¼ˆä»…å¯¹æ–‡æœ¬æ–‡ä»¶ï¼‰
          if (isTextFile(item.name)) {
            const editBtn = document.createElement('button');
            editBtn.title = 'ç¼–è¾‘';
            editBtn.innerHTML = icons.edit;
            editBtn.onclick = (e) => { e.stopPropagation(); editFile(pathDomain, fullKey); };
            actions.appendChild(editBtn);
          }
          
          // å¤åˆ¶/ç§»åŠ¨æŒ‰é’®
          const copyMoveBtn = document.createElement('button');
          copyMoveBtn.title = 'å¤åˆ¶/ç§»åŠ¨';
          copyMoveBtn.innerHTML = icons.copy;
          copyMoveBtn.onclick = (e) => { e.stopPropagation(); showCopyMoveModal(pathDomain, fullKey); };
          actions.appendChild(copyMoveBtn);
          
          // é‡å‘½åæŒ‰é’®
          const renameBtn = document.createElement('button');
          renameBtn.title = 'é‡å‘½å';
          renameBtn.innerHTML = icons.rename;
          renameBtn.onclick = (e) => { e.stopPropagation(); showRenameModal(pathDomain, fullKey); };
          actions.appendChild(renameBtn);
          
          // ä¸‹è½½æŒ‰é’®
          const downloadBtn = document.createElement('button');
          downloadBtn.title = 'ä¸‹è½½';
          downloadBtn.innerHTML = icons.download;
          downloadBtn.onclick = (e) => { e.stopPropagation(); downloadFile(pathDomain, fullKey); };
          actions.appendChild(downloadBtn);

          // åˆ é™¤æŒ‰é’®
          const deleteBtn = document.createElement('button');
          deleteBtn.title = 'åˆ é™¤';
          deleteBtn.innerHTML = icons.delete;
          deleteBtn.onclick = (e) => { e.stopPropagation(); deleteFile(pathDomain, fullKey); };
          actions.appendChild(deleteBtn);
          li.appendChild(actions);
        }
        fileListEl.appendChild(li);
      });
    }
    
    // åˆ¤æ–­æ˜¯å¦ä¸ºæ–‡æœ¬æ–‡ä»¶
    function isTextFile(filename) {
      const textExtensions = ['txt', 'js', 'json', 'html', 'css', 'md', 'xml', 'yml', 'yaml', 'csv', 'log', 'sh'];
      const extension = filename.split('.').pop().toLowerCase();
      return textExtensions.includes(extension);
    }
    
    // æ˜¾ç¤ºå¤åˆ¶/ç§»åŠ¨æ¨¡æ€æ¡†
    function showCopyMoveModal(domain, filePath) {
      currentFileForOperation = { domain, filePath };
      document.getElementById('copy-move-source').textContent = filePath;
      document.getElementById('copy-move-destination').value = filePath;
      document.getElementById('copy-move-modal').style.display = 'block';
      
      // æ„å»ºç›®å½•æ ‘
      buildDirectoryTree(domain, filePath);
    }
    
    // æ„å»ºç›®å½•æ ‘
    function buildDirectoryTree(domain, filePath) {
      const treeContainer = document.getElementById('directory-tree');
      treeContainer.innerHTML = '';
      
      // è·å–æ‰€æœ‰åŸŸå
      const domains = Object.keys(allFilesByDomain).filter(k => k !== 'currentDomain');
      
      // åªæ˜¾ç¤ºåŸŸåç›®å½•
      const ul = document.createElement('ul');
      domains.forEach(domainName => {
        const li = document.createElement('li');
        li.className = 'folder';
        li.textContent = domainName;
        li.dataset.domain = domainName;
        
        li.onclick = (e) => {
          e.stopPropagation();
          
          // æ„é€ ç›®æ ‡è·¯å¾„ï¼šåŸŸå + åŸæ–‡ä»¶å
          const fileName = filePath.split('/').pop();
          const destinationPath = domainName + '/' + fileName;
          
          document.getElementById('copy-move-destination').value = destinationPath;
          
          // é«˜äº®é€‰ä¸­é¡¹
          document.querySelectorAll('.directory-tree li').forEach(item => {
            item.classList.remove('selected');
          });
          li.classList.add('selected');
        };
        
        ul.appendChild(li);
      });
      treeContainer.appendChild(ul);
    }
    
    // æ˜¾ç¤ºé‡å‘½åæ¨¡æ€æ¡†
    function showRenameModal(domain, filePath) {
      currentFileForOperation = { domain, filePath };
      document.getElementById('rename-source').textContent = filePath;
      document.getElementById('rename-destination').value = filePath.split('/').pop(); // åªæ˜¾ç¤ºæ–‡ä»¶å
      document.getElementById('rename-modal').style.display = 'block';
    }

    // å¤„ç†æ–°å»ºæ–‡ä»¶ç¡®è®¤
    async function handleNewFileConfirm() {
      const filename = document.getElementById('new-filename').value.trim();
      if (!filename) {
        showStatus('è¯·è¾“å…¥æ–‡ä»¶å', true);
        return;
      }

      document.getElementById('new-file-modal').style.display = 'none';

      const pathDomain = currentPath.split('/')[0];
      const pathWithinDomain = currentPath.substring(pathDomain.length + 1);
      const remoteKey = pathWithinDomain + filename;
      const isRemote = pathDomain !== currentDomain;
      const apiPath = isRemote ? 'proxy/' + pathDomain + '/update/' + remoteKey : 'update/' + remoteKey;

      try {
        // åˆ›å»ºä¸€ä¸ªç©ºæ–‡ä»¶
        const response = await fetch('/' + apiPath, { 
          method: 'PUT', 
          body: new Blob([], {type: 'text/plain'})
        });
        if (!response.ok) throw new Error(await response.text());
        
        showStatus('æ–‡ä»¶ "' + filename + '" åˆ›å»ºæˆåŠŸ');
        render(); // åˆ·æ–°æ–‡ä»¶åˆ—è¡¨
      } catch (error) {
        showStatus('åˆ›å»ºæ–‡ä»¶æ—¶å‡ºé”™: ' + error.message, true);
      }
    }
    
    // å¤„ç†å¤åˆ¶/ç§»åŠ¨ç¡®è®¤
    async function handleCopyMoveConfirm(operation) {
      const destination = document.getElementById('copy-move-destination').value.trim();
      
      if (!destination) {
        showStatus('è¯·è¾“å…¥ç›®æ ‡è·¯å¾„', true);
        return;
      }
      
      const { domain, filePath } = currentFileForOperation;
      document.getElementById('copy-move-modal').style.display = 'none';
      
      try {
        // ä¸‹è½½æºæ–‡ä»¶
        const downloadPath = (domain === currentDomain) ? filePath : 'proxy/' + domain + '/' + filePath;
        const response = await fetch('/' + downloadPath);
        if (!response.ok) throw new Error('æ— æ³•ä¸‹è½½æºæ–‡ä»¶: ' + response.status + ' ' + response.statusText);
        
        const fileContent = await response.blob();
        
        // ä¸Šä¼ åˆ°æ–°ä½ç½® - éœ€è¦ç¡®å®šç›®æ ‡åŸŸå
        const targetDomain = Object.keys(allFilesByDomain)
          .filter(k => k !== 'currentDomain')
          .find(domainName => destination.startsWith(domainName + '/')) || currentDomain;
          
        // ä»ç›®æ ‡è·¯å¾„ä¸­ç§»é™¤åŸŸåéƒ¨åˆ†ï¼Œå¾—åˆ°åœ¨KVä¸­å®é™…å­˜å‚¨çš„key
        const destinationKey = destination.startsWith(targetDomain + '/')
          ? destination.substring(targetDomain.length + 1)
          : destination;

        // å¦‚æœç›®æ ‡æ˜¯å…¶ä»–åŸŸåï¼Œä½¿ç”¨proxyè·¯å¾„
        const isRemoteTarget = targetDomain !== currentDomain;
        const uploadPath = isRemoteTarget 
          ? 'proxy/' + targetDomain + '/update/' + destinationKey
          : 'update/' + destinationKey;
        
        const uploadResponse = await fetch('/' + uploadPath, { method: 'PUT', body: fileContent });
        if (!uploadResponse.ok) throw new Error('ä¸Šä¼ å¤±è´¥: ' + uploadResponse.status + ' ' + await uploadResponse.text());
        
        // å¦‚æœæ˜¯ç§»åŠ¨æ“ä½œï¼Œåˆ é™¤æºæ–‡ä»¶
        if (operation === 'move') {
          const deletePath = (domain === currentDomain) ? 'delete/' + filePath : 'proxy/' + domain + '/delete/' + filePath;
          const deleteResponse = await fetch('/' + deletePath, { method: 'DELETE' });
          if (!deleteResponse.ok) throw new Error('åˆ é™¤æºæ–‡ä»¶å¤±è´¥: ' + await deleteResponse.text());
          showStatus('æ–‡ä»¶ç§»åŠ¨æˆåŠŸ');
        } else {
          showStatus('æ–‡ä»¶å¤åˆ¶æˆåŠŸ');
        }
        
        render();
      } catch (error) {
        showStatus((operation === 'move' ? 'ç§»åŠ¨' : 'å¤åˆ¶') + 'æ–‡ä»¶æ—¶å‡ºé”™: ' + error.message, true);
      }
    }
    
    // å¤„ç†é‡å‘½åç¡®è®¤
    async function handleRenameConfirm() {
      const newName = document.getElementById('rename-destination').value.trim();
      if (!newName) {
        showStatus('è¯·è¾“å…¥æ–°åç§°', true);
        return;
      }
      
      const { domain, filePath } = currentFileForOperation;
      const pathParts = filePath.split('/');
      pathParts[pathParts.length - 1] = newName;
      const newPath = pathParts.join('/');
      
      document.getElementById('rename-modal').style.display = 'none';
      
      try {
        // ä¸‹è½½æºæ–‡ä»¶
        const downloadPath = (domain === currentDomain) ? filePath : 'proxy/' + domain + '/' + filePath;
        const response = await fetch('/' + downloadPath);
        if (!response.ok) throw new Error('æ— æ³•ä¸‹è½½æºæ–‡ä»¶');
        
        const fileContent = await response.blob();
        
        // ä¸Šä¼ åˆ°æ–°åç§°
        const isRemote = domain !== currentDomain;
        const uploadPath = isRemote ? 'proxy/' + domain + '/update/' + newPath : 'update/' + newPath;
        
        const uploadResponse = await fetch('/' + uploadPath, { method: 'PUT', body: fileContent });
        if (!uploadResponse.ok) throw new Error(await uploadResponse.text());
        
        // åˆ é™¤æºæ–‡ä»¶
        const deletePath = isRemote ? 'proxy/' + domain + '/delete/' + filePath : 'delete/' + filePath;
        const deleteResponse = await fetch('/' + deletePath, { method: 'DELETE' });
        if (!deleteResponse.ok) throw new Error(await deleteResponse.text());
        
        showStatus('æ–‡ä»¶é‡å‘½åæˆåŠŸ');
        render();
      } catch (error) {
        showStatus('é‡å‘½åæ–‡ä»¶æ—¶å‡ºé”™: ' + error.message, true);
      }
    }
    
    // ç¼–è¾‘æ–‡ä»¶
    async function editFile(domain, filePath) {
      try {
        const downloadPath = (domain === currentDomain) ? filePath : 'proxy/' + domain + '/' + filePath;
        const response = await fetch('/' + downloadPath);
        if (!response.ok) throw new Error('æ— æ³•ä¸‹è½½æ–‡ä»¶');
        
        const content = await response.text();
        
        document.getElementById('editor-filename').textContent = filePath;
        document.getElementById('editor-textarea').value = content;
        currentFileForOperation = { domain, filePath };
        document.getElementById('editor-modal').style.display = 'block';
      } catch (error) {
        showStatus('æ‰“å¼€æ–‡ä»¶ç¼–è¾‘å™¨æ—¶å‡ºé”™: ' + error.message, true);
      }
    }

    // JSON æ ¼å¼åŒ–/å‹ç¼©
    function formatJson(beautify) {
      const textarea = document.getElementById('editor-textarea');
      try {
        const jsonObj = JSON.parse(textarea.value);
        if (beautify) {
          textarea.value = JSON.stringify(jsonObj, null, 2); // æ ¼å¼åŒ–ï¼Œ2ä¸ªç©ºæ ¼ç¼©è¿›
        } else {
          textarea.value = JSON.stringify(jsonObj); // å‹ç¼©
        }
        showStatus(beautify ? 'JSON æ ¼å¼åŒ–æˆåŠŸ' : 'JSON å‹ç¼©æˆåŠŸ');
      } catch (error) {
        showStatus('é”™è¯¯: æ— æ•ˆçš„ JSON å†…å®¹ã€‚ ' + error.message, true);
      }
    }
    
    // ä¿å­˜ç¼–è¾‘åçš„æ–‡ä»¶
    async function handleSaveEditor() {
      const { domain, filePath } = currentFileForOperation;
      const content = document.getElementById('editor-textarea').value;
      
      try {
        const isRemote = domain !== currentDomain;
        const uploadPath = isRemote ? 'proxy/' + domain + '/update/' + filePath : 'update/' + filePath;
        
        const response = await fetch('/' + uploadPath, {
          method: 'PUT',
          body: content,
          headers: { 'Content-Type': 'text/plain' }
        });
        
        if (!response.ok) throw new Error(await response.text());
        
        document.getElementById('editor-modal').style.display = 'none';
        showStatus('æ–‡ä»¶ä¿å­˜æˆåŠŸ');
        render();
      } catch (error) {
        showStatus('ä¿å­˜æ–‡ä»¶æ—¶å‡ºé”™: ' + error.message, true);
      }
    }
    
    function downloadFile(domain, filePath) {
        const path = (domain === currentDomain) ? filePath : 'proxy/' + domain + '/' + filePath;
        window.location.href = '/' + path;
    }

    async function handleFileUpload(event) {
      const files = event.target.files;
      if (files.length === 0) return;
      
      const pathDomain = currentPath.split('/')[0];
      if (!pathDomain) {
          showStatus('ä¸èƒ½åœ¨æ ¹ç›®å½•ä¸Šä¼ æ–‡ä»¶ï¼Œè¯·å…ˆè¿›å…¥ä¸€ä¸ªåŸŸåç›®å½•ã€‚', true);
          return;
      }
      
      const pathWithinDomain = currentPath.substring(pathDomain.length + 1);

      showStatus('å¼€å§‹ä¸Šä¼  ' + files.length + ' ä¸ªæ–‡ä»¶...');
      for (const file of files) {
        const remoteKey = pathWithinDomain + file.name;
        const isRemote = pathDomain !== currentDomain;
        const apiPath = isRemote ? 'proxy/' + pathDomain + '/update/' + remoteKey : 'update/' + remoteKey;
        
        try {
          const response = await fetch('/' + apiPath, { method: 'PUT', body: file });
          if (!response.ok) throw new Error(await response.text());
          showStatus('æ–‡ä»¶ "' + file.name + '" ä¸Šä¼ æˆåŠŸ!');
        } catch (error) {
          showStatus('ä¸Šä¼  "' + file.name + '" æ—¶å‡ºé”™: ' + error.message, true);
        }
      }
      event.target.value = '';
      render();
    }

    async function deleteFile(domain, filePath) {
      if (!confirm('ç¡®å®šè¦åˆ é™¤æ–‡ä»¶ "' + filePath + '" å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚')) return;
      
      const isRemote = domain !== currentDomain;
      const apiPath = isRemote ? 'proxy/' + domain + '/delete/' + filePath : 'delete/' + filePath;

      try {
        const response = await fetch('/' + apiPath, { method: 'DELETE' });
        if (!response.ok) throw new Error(await response.text());
        showStatus('æ–‡ä»¶ "' + filePath + '" å·²åˆ é™¤ã€‚');
        render();
      } catch (error) {
        showStatus('åˆ é™¤æ–‡ä»¶æ—¶å‡ºé”™: ' + error.message, true);
      }
    }
  </script>
</body>
</html>
`;

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const path = url.pathname.substring(1);

    // --- ç»Ÿä¸€èº«ä»½éªŒè¯ ---
    const { JIANGUO_USERNAME, JIANGUO_PASSWORD, MY_SCRIPT_BUCKET, OTHER_DOMAINS } = env;
    if (!JIANGUO_USERNAME || !JIANGUO_PASSWORD) {
      return new Response('é”™è¯¯ï¼šæœªé…ç½®ç”¨æˆ·åæˆ–å¯†ç ç¯å¢ƒå˜é‡ã€‚\n', { status: 500 });
    }
    const authHeader = request.headers.get('Authorization');
    const credentials = decodeBasicAuth(authHeader);
    if (!credentials || credentials.username !== JIANGUO_USERNAME || credentials.password !== JIANGUO_PASSWORD) {
      return new Response('æœªæˆæƒè®¿é—®ã€‚\n', {
        status: 401,
        headers: { 'WWW-Authenticate': 'Basic realm="KV Cross-Domain File Manager"' }
      });
    }
    
    const requestAuthHeader = getAuthHeader(JIANGUO_USERNAME, JIANGUO_PASSWORD);

    // --- ä»£ç†è·¯ç”± ---
    if (path.startsWith('proxy/')) {
      const parts = path.split('/');
      const targetDomain = parts[1];
      const targetPath = parts.slice(2).join('/');
      
      if (!targetDomain || !targetPath) {
        return new Response('ä»£ç†è¯·æ±‚æ ¼å¼é”™è¯¯ã€‚\n', { status: 400 });
      }

      const targetUrl = `https://${targetDomain}/${targetPath}`;
      const proxyHeaders = new Headers(request.headers);
      proxyHeaders.set('Authorization', requestAuthHeader);

      try {
        const response = await fetch(targetUrl, {
          method: request.method,
          headers: proxyHeaders,
          body: request.body,
        });
        return new Response(response.body, response);
      } catch (e) {
        return new Response(`ä»£ç†è¯·æ±‚å¤±è´¥: ${e.message}\n`, { status: 500 });
      }
    }

    // --- API è·¯ç”± ---
    // ä¸Šä¼ /æ›´æ–°
    if (request.method === 'PUT' && path.startsWith('update/')) {
      const filename = path.substring('update/'.length);
      if (!filename) return new Response('é”™è¯¯ï¼šæœªæŒ‡å®šæ–‡ä»¶åã€‚\n', { status: 400 });
      await MY_SCRIPT_BUCKET.put(filename, request.body);
      return new Response(`æ–‡ä»¶ "${filename}" å·²æˆåŠŸæ›´æ–°ã€‚\n`, { status: 200 });
    }

    // åˆ é™¤
    if (request.method === 'DELETE' && path.startsWith('delete/')) {
      const filename = path.substring('delete/'.length);
      if (!filename) return new Response('é”™è¯¯ï¼šæœªæŒ‡å®šæ–‡ä»¶åã€‚\n', { status: 400 });
      await MY_SCRIPT_BUCKET.delete(filename);
      return new Response(`æ–‡ä»¶ "${filename}" å·²æˆåŠŸåˆ é™¤ã€‚\n`, { status: 200 });
    }

    // åˆ—å‡ºæ‰€æœ‰é”® (æ ¸å¿ƒå¤šåŸŸåé€»è¾‘)
    if (request.method === 'GET' && path === 'list-keys') {
      const currentDomain = url.hostname;
      let allFilesByDomain = { currentDomain };

      // 1. è·å–æœ¬åœ°æ–‡ä»¶
      const localList = await MY_SCRIPT_BUCKET.list();
      const localKeys = localList.keys.map(k => k.name);
      allFilesByDomain[currentDomain] = localKeys;

      // 2. è·å–è¿œç¨‹æ–‡ä»¶
      const otherDomains = (OTHER_DOMAINS || '').split(',').map(d => d.trim()).filter(Boolean);
      const remoteFetchPromises = otherDomains.map(domain => 
        fetch(`https://${domain}/list-keys-flat`, { headers: { 'Authorization': requestAuthHeader } })
          .then(res => {
              if (!res.ok) return Promise.reject(new Error(`Failed to fetch from ${domain}: ${res.statusText}`));
              return res.json();
          })
          .then(data => ({ domain, keys: data.keys })) // å‡è®¾è¿œç¨‹è¿”å› {keys: [...]}
          .catch(err => ({ domain, error: err.message, keys: [] }))
      );
      
      const results = await Promise.all(remoteFetchPromises);
      results.forEach(result => {
        allFilesByDomain[result.domain] = result.keys;
      });

      return new Response(JSON.stringify(allFilesByDomain), {
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
    
    // æ–°å¢ä¸€ä¸ªåªè¿”å›æœ¬åœ°åŸŸåé”®çš„å†…éƒ¨ç«¯ç‚¹
    if (request.method === 'GET' && path === 'list-keys-flat') {
        const localList = await MY_SCRIPT_BUCKET.list();
        const localKeys = localList.keys.map(k => k.name);
        return new Response(JSON.stringify({ keys: localKeys }), {
            headers: { 'Content-Type': 'application/json;charset=UTF-8' }
        });
    }


    // --- UI å’Œæ–‡ä»¶ä¸‹è½½ ---
    if (path === '') {
      return new Response(fileManagerHtml, {
        headers: { 'Content-Type': 'text/html;charset=UTF-8' }
      });
    }

    // å…¶ä»–è·¯å¾„è§†ä¸ºæ–‡ä»¶ä¸‹è½½
    const file = await MY_SCRIPT_BUCKET.get(path, { type: 'stream' });
    if (file === null) {
      return new Response(`æœªæ‰¾åˆ°æ–‡ä»¶: ${path}\n`, { status: 404 });
    }
    return new Response(file, {
      headers: {
        'Content-Type': guessContentType(path),
        'Content-Disposition': `attachment; filename="${path.split('/').pop()}"`
      }
    });
  },
};
